
{
"version": "1.0",
"purpose": "Supabase（Postgres/RLS/Realtime）をチャット＆管理画面の本番運用に耐える形で初期構築するための完全指示。Claude Code + Supabase MCP がそのまま実行できるよう、マイグレーションSQL・RLS・トリガ・検証クエリ・変数を網羅。",
"prerequisites": {
"need": \[
"Supabase プロジェクト（Project URL / anon key / service role key）",
"Supabase CLI（任意）または MCP から SQL 実行権限",
"Authユーザー（管理者に昇格する初回ログイン済みの user\_id）"
],
"nice\_to\_have": \[
"Vercel 環境（Next.js API 用）",
"Sentry DSN（任意）"
]
},
"variables": {
"SUPABASE\_PROJECT\_URL": "[https://YOUR-PROJECT.supabase.co](https://YOUR-PROJECT.supabase.co)",
"SUPABASE\_ANON\_KEY": "REDACTED",
"SUPABASE\_SERVICE\_ROLE\_KEY": "REDACTED",
"ADMIN\_USER\_ID": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
"STORAGE\_BUCKET\_ATTACHMENTS": "chat-attachments"
},
"env\_for\_vercel": {
"required": \[
"SUPABASE\_URL",
"SUPABASE\_ANON\_KEY",
"SUPABASE\_SERVICE\_ROLE\_KEY",
"NEXT\_PUBLIC\_BASE\_URL",
"NEXT\_PUBLIC\_CHAT\_ENABLED",
"NEXT\_PUBLIC\_USE\_MOCK",
"NEXT\_PUBLIC\_FEATURE\_LINE"
],
"example": {
"SUPABASE\_URL": "\${SUPABASE\_PROJECT\_URL}",
"SUPABASE\_ANON\_KEY": "\${SUPABASE\_ANON\_KEY}",
"SUPABASE\_SERVICE\_ROLE\_KEY": "\${SUPABASE\_SERVICE\_ROLE\_KEY}",
"NEXT\_PUBLIC\_BASE\_URL": "[https://foodphoto-pro.com](https://foodphoto-pro.com)",
"NEXT\_PUBLIC\_CHAT\_ENABLED": "true",
"NEXT\_PUBLIC\_USE\_MOCK": "false",
"NEXT\_PUBLIC\_FEATURE\_LINE": "false"
}
},
"operations": \[
{
"id": "0000\_ping",
"type": "info",
"description": "準備OKか確認のみ（実行不要）。以降の steps を順に実行。"
},
{
"id": "0001\_extensions\_enums",
"type": "sql",
"sql": "create extension if not exists pgcrypto; create extension if not exists pg\_trgm; do $begin create type public.channel as enum ('web','line'); exception when duplicate_object then null; end$; do $begin create type public.conversation_status as enum ('new','active','snoozed','closed'); exception when duplicate_object then null; end$; do $begin create type public.message_role as enum ('user','agent','system'); exception when duplicate_object then null; end$; do $begin create type public.message_source as enum ('web','admin','line'); exception when duplicate_object then null; end$; do $begin create type public.event_type as enum ('opened','first_response','assigned','closed','reopened','tag_added','tag_removed'); exception when duplicate_object then null; end$;"
},
{
"id": "0002\_core\_tables",
"type": "sql",
"sql": "create table if not exists public.profiles ( user\_id uuid primary key references auth.users(id) on delete cascade, role text not null default 'staff' check (role in ('admin','staff')), display\_name text, created\_at timestamptz default now() ); create table if not exists public.conversations ( id uuid primary key default gen\_random\_uuid(), channel public.channel not null default 'web', status public.conversation\_status not null default 'new', contact\_name text, contact\_email text, line\_user\_id text, session\_token text, source\_url text, utm\_source text, utm\_medium text, utm\_campaign text, referrer\_domain text, user\_agent text, tags text\[] default '{}'::text\[], assigned\_to uuid references auth.users(id) on delete set null, created\_at timestamptz default now(), last\_message\_at timestamptz ); create index if not exists conv\_status\_last\_idx on public.conversations (status, last\_message\_at desc); create index if not exists conv\_session\_idx on public.conversations (session\_token); create index if not exists conv\_line\_idx on public.conversations (line\_user\_id); create index if not exists conv\_source\_url\_idx on public.conversations (source\_url); create index if not exists conv\_tags\_idx on public.conversations using gin (tags); create table if not exists public.messages ( id uuid primary key default gen\_random\_uuid(), conversation\_id uuid not null references public.conversations(id) on delete cascade, role public.message\_role not null, source public.message\_source not null, content text not null, content\_type text default 'text/plain', attachment\_url text, created\_by uuid references auth.users(id) on delete set null, is\_internal boolean default false, created\_at timestamptz default now(), delivered\_to\_line boolean default false ); create index if not exists msg\_conv\_created\_idx on public.messages (conversation\_id, created\_at); create index if not exists msg\_created\_by\_idx on public.messages (created\_by); create index if not exists msg\_trgm\_content\_idx on public.messages using gin (content gin\_trgm\_ops); create index if not exists msg\_user\_recent\_idx on public.messages (conversation\_id, created\_at) where role = 'user'; create table if not exists public.conversation\_reads ( conversation\_id uuid references public.conversations(id) on delete cascade, user\_id uuid references auth.users(id) on delete cascade, last\_read\_at timestamptz not null default now(), primary key (conversation\_id, user\_id) ); create table if not exists public.conversation\_events ( id uuid primary key default gen\_random\_uuid(), conversation\_id uuid not null references public.conversations(id) on delete cascade, type public.event\_type not null, actor uuid references auth.users(id) on delete set null, meta jsonb not null default '{}'::jsonb, created\_at timestamptz default now() ); create index if not exists conv\_events\_idx on public.conversation\_events (conversation\_id, created\_at); create table if not exists public.reply\_templates ( id uuid primary key default gen\_random\_uuid(), title text not null, body text not null, tags text\[] default '{}'::text\[], created\_by uuid references auth.users(id) on delete set null, created\_at timestamptz default now(), updated\_at timestamptz default now() ); create index if not exists reply\_templates\_tags\_idx on public.reply\_templates using gin (tags); create table if not exists public.conversation\_links ( id uuid primary key default gen\_random\_uuid(), conversation\_id uuid not null references public.conversations(id) on delete cascade, token\_hash text not null, expires\_at timestamptz not null, created\_at timestamptz default now(), unique (token\_hash) ); create index if not exists conv\_links\_conv\_idx on public.conversation\_links (conversation\_id); create index if not exists conv\_links\_exp\_idx on public.conversation\_links (expires\_at); create table if not exists public.attachments ( id uuid primary key default gen\_random\_uuid(), message\_id uuid not null references public.messages(id) on delete cascade, file\_url text not null, mime\_type text, bytes integer, created\_at timestamptz default now() ); create table if not exists public.audit\_logs ( id uuid primary key default gen\_random\_uuid(), actor uuid references auth.users(id) on delete set null, action text not null, target\_type text not null, target\_id uuid not null, meta jsonb not null default '{}'::jsonb, created\_at timestamptz default now() ); create index if not exists audit\_target\_idx on public.audit\_logs (target\_type, target\_id, created\_at);"
},
{
"id": "0003\_rls\_policies",
"type": "sql",
"sql": "alter table public.conversations enable row level security; alter table public.messages enable row level security; alter table public.profiles enable row level security; alter table public.conversation\_reads enable row level security; alter table public.conversation\_events enable row level security; alter table public.reply\_templates enable row level security; alter table public.conversation\_links enable row level security; alter table public.attachments enable row level security; alter table public.audit\_logs enable row level security; create or replace function public.is\_admin() returns boolean language sql stable as $select exists (select 1 from public.profiles p where p.user_id = auth.uid() and p.role = 'admin')$; create policy if not exists conversations\_select on public.conversations for select to authenticated using (true); create policy if not exists conversations\_update on public.conversations for update to authenticated using (public.is\_admin() or assigned\_to = auth.uid()); create policy if not exists messages\_select on public.messages for select to authenticated using (true); create policy if not exists messages\_insert on public.messages for insert to authenticated with check (created\_by = auth.uid()); create policy if not exists reads\_select on public.conversation\_reads for select to authenticated using (true); create policy if not exists reads\_upsert on public.conversation\_reads for insert to authenticated with check (user\_id = auth.uid()); create policy if not exists reads\_update on public.conversation\_reads for update to authenticated using (user\_id = auth.uid()); create policy if not exists events\_select on public.conversation\_events for select to authenticated using (true); create policy if not exists events\_insert on public.conversation\_events for insert to authenticated with check (true); create policy if not exists templates\_select on public.reply\_templates for select to authenticated using (true); create policy if not exists templates\_cud on public.reply\_templates for all to authenticated using (created\_by = auth.uid() or public.is\_admin()) with check (created\_by = auth.uid() or public.is\_admin()); create policy if not exists attachments\_select on public.attachments for select to authenticated using (true); create policy if not exists attachments\_insert on public.attachments for insert to authenticated with check (true); create policy if not exists audits\_select on public.audit\_logs for select to authenticated using (public.is\_admin()); create policy if not exists audits\_insert on public.audit\_logs for insert to authenticated with check (true);"
},
{
"id": "0004\_helpers\_triggers",
"type": "sql",
"sql": "create or replace function public.unread\_count(p\_conversation\_id uuid) returns integer language sql stable security definer as $with r as ( select last_read_at from public.conversation_reads where conversation_id = p_conversation_id and user_id = auth.uid() ) select count(1) from public.messages m left join r on true where m.conversation_id = p_conversation_id and m.role = 'user' and (r.last_read_at is null or m.created_at > r.last_read_at);$; create or replace function public.tg\_messages\_after\_insert() returns trigger language plpgsql security definer as $declare prev_agent_count int; prev_status public.conversation_status; begin select status into prev_status from public.conversations where id = NEW.conversation_id; update public.conversations set last_message_at = NEW.created_at, status = case when NEW.role = 'user' and prev_status = 'closed' then 'new' when NEW.role = 'agent' and prev_status in ('new','snoozed') then 'active' else prev_status end where id = NEW.conversation_id; if NEW.role = 'agent' then select count(1) into prev_agent_count from public.messages where conversation_id = NEW.conversation_id and role = 'agent' and id <> NEW.id; if coalesce(prev_agent_count,0) = 0 then insert into public.conversation_events (conversation_id, type, actor, created_at) values (NEW.conversation_id, 'first_response', NEW.created_by, NEW.created_at); end if; elsif NEW.role = 'user' and prev_status = 'closed' then insert into public.conversation_events (conversation_id, type, actor, created_at) values (NEW.conversation_id, 'reopened', null, NEW.created_at); end if; return NEW; end$; drop trigger if exists trg\_messages\_after\_insert on public.messages; create trigger trg\_messages\_after\_insert after insert on public.messages for each row execute function public.tg\_messages\_after\_insert(); create or replace function public.tg\_conversations\_after\_update() returns trigger language plpgsql security definer as $begin if NEW.assigned_to is distinct from OLD.assigned_to then insert into public.conversation_events (conversation_id, type, actor, meta) values (NEW.id, 'assigned', auth.uid(), jsonb_build_object('from', OLD.assigned_to, 'to', NEW.assigned_to)); end if; if NEW.status <> OLD.status then if NEW.status = 'closed' then insert into public.conversation_events (conversation_id, type, actor) values (NEW.id, 'closed', auth.uid()); elsif OLD.status = 'closed' and NEW.status in ('new','active','snoozed') then insert into public.conversation_events (conversation_id, type, actor) values (NEW.id, 'reopened', auth.uid()); end if; end if; return NEW; end$; drop trigger if exists trg\_conversations\_after\_update on public.conversations; create trigger trg\_conversations\_after\_update after update on public.conversations for each row execute function public.tg\_conversations\_after\_update();"
},
{
"id": "0005\_seed\_admin",
"type": "sql",
"sql": "insert into public.profiles (user\_id, role, display\_name) values ('\${ADMIN\_USER\_ID}','admin','Owner') on conflict (user\_id) do update set role='admin';"
},
{
"id": "0006\_seed\_templates\_optional",
"type": "sql",
"optional": true,
"sql": "insert into public.reply\_templates (title, body, tags, created\_by) values ('初回ご挨拶','お問い合わせありがとうございます。撮影のご希望日時と、点数（品数）をお知らせください。こちらから最短の空き枠をご案内します。', array\['見積','初回'], '\${ADMIN\_USER\_ID}'::uuid) on conflict do nothing;"
},
{
"id": "0007\_storage\_bucket\_optional",
"type": "sql",
"optional": true,
"sql": "insert into storage.buckets (id, name, public) values ('\${STORAGE\_BUCKET\_ATTACHMENTS}','\${STORAGE\_BUCKET\_ATTACHMENTS}', false) on conflict (id) do nothing; -- Storage RLSは signed URL 運用想定のため別途実装（将来）"
}
],
"realtime\_subscriptions": \[
{
"table": "public.conversations",
"events": \["INSERT", "UPDATE"],
"filter": "*",
"client\_usage\_note": "管理画面の左ペインリスト用。更新時はソート: status rank → last\_message\_at desc。"
},
{
"table": "public.messages",
"events": \["INSERT"],
"filter": "conversation\_id=eq.{ACTIVE\_CONVERSATION\_ID}",
"client\_usage\_note": "スレッド詳細。選択中会話のみ購読して混線防止。"
}
],
"api\_contract\_reference": {
"note": "実APIは Next.js 側。ここでは Supabase 側の期待を明記（MCPは参照のみ）。",
"chat\_start": {
"method": "POST /api/chat/start",
"server\_action": "conversations に row upsert（channel='web', session\_token, last\_message\_at=now(), UIからの context 列を保存）",
"returns": "{ conversationId }"
},
"chat\_send": {
"method": "POST /api/chat/send",
"server\_action": "messages へ {conversation\_id, role='user', source='web', content} を insert。conversations.last\_message\_at を更新。",
"returns": "{ ok: true }"
},
"admin\_reply": {
"method": "POST /api/admin/reply",
"auth": "Supabase Auth 必須（RLSで created\_by=auth.uid()）",
"server\_action": "messages へ {role='agent', source='admin', created\_by} を insert。conversations.assigned\_to を未設定なら自動で自分に。",
"returns": "{ ok: true }"
},
"read\_upsert": {
"method": "POST /api/admin/read",
"server\_action": "conversation\_reads に upsert（conversation\_id, user\_id=auth.uid(), last\_read\_at=now()）",
"returns": "{ ok: true }"
}
},
"smoke\_tests\_sql": \[
"select 'tables\_ready' as label, count(*) filter (where tablename in ('conversations','messages','profiles')) as present from pg\_tables where schemaname='public';",
"insert into public.conversations(channel,status,session\_token,last\_message\_at) values ('web','new','test-sid', now()) returning id;",
"-- ↑ 返った id を {CID} に置換して以下を実行",
"insert into public.messages(conversation\_id,role,source,content,created\_by) values ('{CID}','user','web','テスト問い合わせ',null);",
"select status, last\_message\_at from public.conversations where id='{CID}';",
"select public.unread\_count('{CID}');"
],
"security\_notes": \[
"Service Role Key は Next.js API（サーバー）でのみ使用。フロントには絶対に出さない。",
"RLS により、管理画面は authenticated のみ読取可能・書込は作成者に限定。",
"conversation\_links は基本サーバ専用（ポリシー未付与で封鎖）。",
"Storage は将来 signed URL 運用を推奨（現時点では添付は未使用）。"
],
"mapping\_ui\_to\_db": {
"chat\_modal": \[
"起動時に /api/chat/start へ {source\_url, utm\_source, utm\_medium, utm\_campaign, referrer\_domain, user\_agent} を送信 → conversations.\* に保存",
"送信時 /api/chat/send → messages.insert → triggers が conversations.status/last\_message\_at を更新"
],
"admin\_inbox": \[
"一覧: conversations を status, last\_message\_at で取得（または購読）",
"詳細: messages where conversation\_id=\:id （購読フィルタ付き）",
"既読: conversation\_reads upsert（右ペイン表示時）",
"返信: /api/admin/reply → messages.insert(role='agent', created\_by=auth.uid()) → first\_response イベント自動発火"
],
"badges\_and\_sla": \[
"未読バッジ: unread\_count(conversation\_id)",
"SLA: conversation\_events の first\_response / closed から算出（将来の集計用）"
]
},
"rollback\_plan": {
"safe\_toggle": \[
"NEXT\_PUBLIC\_CHAT\_ENABLED=false（UI非表示）",
"CHAT\_API\_DISABLED=true（API 503 応答）"
],
"db\_rollback": "CREATE TABLE を DROP する前にバックアップ（supabase db dump）。イベント/既読テーブルは削除しても元会話とメッセージは保持される。"
},
"done\_definition": \[
"マイグレーションSQLが全て成功（エラーなし）",
"profiles に ADMIN\_USER\_ID が admin として登録されている",
"smoke\_tests\_sql の実行で last\_message\_at が更新・unread\_count が 1 を返す",
"管理画面で認証後、conversations/messages が購読できる（Realtime 反映）"
]
}
