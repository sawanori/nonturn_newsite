{
    "version": "1.0.0",
    "purpose": "ユーザー投稿時に管理者へ LINE（Messaging API）で“管理画面URL付き”通知を送る。5分クールダウン付き。groupId/userId は Webhook から取得し、Vercel 環境変数に設定して運用する。",
    "assumptions": {
    "framework": "Next.js (App Router), TypeScript, Node runtime on Vercel",
    "db": "Supabase（前工程でスキーマ/RLS/トリガ適用済み）",
    "chat\_api": "既存の /api/chat/start, /api/chat/send, /api/chat/history が稼働中",
    "env\_already\_set": true,
    "note": "この仕様書は“実装を自動化する生成AI”向け。記載のファイルはそのまま新規作成/上書きしてよい。"
    },
    "env\_required": \[
    "SUPABASE\_URL",
    "SUPABASE\_SERVICE\_ROLE\_KEY",
    "LINE\_CHANNEL\_ID",
    "LINE\_CHANNEL\_SECRET",
    "LINE\_CHANNEL\_ACCESS\_TOKEN",
    "ADMIN\_INBOX\_URL",
    "ADMIN\_NOTIFY\_COOLDOWN\_MINUTES",
    "ADMIN\_NOTIFY\_ENABLED",
    "LINE\_ADMIN\_GROUP\_ID (任意：グループ宛て)",
    "LINE\_ADMIN\_USER\_IDS (任意：個人宛て、カンマ区切り)"
    ],
    "setup\_order": \[
    "1) Webhookルート（/api/line/webhook）を作成して署名検証＆IDロギングを実装",
    "2) デプロイ → LINE Developersで Webhook URL を設定＆接続確認",
    "3) LINEアプリで管理用グループ作成→Bot招待→グループで発言→Vercelログから groupId を取得",
    "4) 取得した groupId を Vercel 環境変数 LINE\_ADMIN\_GROUP\_ID に保存（または userId を LINE\_ADMIN\_USER\_IDS に保存）",
    "5) 管理者通知ユーティリティ（lib/line/adminNotify.ts）を追加",
    "6) /api/chat/send に通知フック＋5分クールダウン（try\_admin\_notify）を組み込み",
    "7) デプロイして動作確認（E2E＋クールダウン動作）"
    ],
    "files": \[
    {
    "path": "app/api/line/webhook/route.ts",
    "action": "create\_or\_overwrite",
    "language": "ts",
    "content": "import { NextResponse } from 'next/server';\nimport crypto from 'crypto';\n\nexport const runtime = 'nodejs'; // Node の crypto を使うため\n\nfunction verifySignature(body: string, signature: string | null) {\n  if (!signature) return false;\n  const hmac = crypto.createHmac('sha256', process.env.LINE\_CHANNEL\_SECRET!);\n  hmac.update(body);\n  return hmac.digest('base64') === signature;\n}\n\nexport async function POST(req: Request) {\n  const raw = await req.text();\n  const sig = (req.headers as any).get('x-line-signature');\n  if (!verifySignature(raw, sig)) {\n    console.warn('LINE webhook: bad signature');\n    return NextResponse.json({ ok: false }, { status: 401 });\n  }\n\n  const payload = JSON.parse(raw);\n\n  // 必要に応じてイベント処理を追加。ここでは ID ログ出力に徹する。\n  for (const ev of payload.events ?? \[]) {\n    // グループからのイベント（招待後にグループで発言すると届く）\n    if (ev.source?.groupId) {\n      console.log('LINE\_ADMIN\_GROUP\_ID candidate:', ev.source.groupId);\n    }\n    // 1:1 の場合（管理者個人とのトークなど）\n    if (ev.source?.userId) {\n      console.log('LINE\_ADMIN\_USER\_ID candidate:', ev.source.userId);\n    }\n  }\n\n  return NextResponse.json({ ok: true });\n}\n"
    },
    {
    "path": "lib/line/adminNotify.ts",
    "action": "create\_or\_overwrite",
    "language": "ts",
    "content": "export const runtime = 'nodejs';\n\nasync function push(payload: any) {\n  const r = await fetch('[https://api.line.me/v2/bot/message/push](https://api.line.me/v2/bot/message/push)', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${process.env.LINE_CHANNEL_ACCESS_TOKEN!}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(payload)\n  });\n  if (!r.ok) {\n    const msg = await r.text().catch(()=>'');\n    console.error('LINE push failed', r.status, msg);\n  }\n}\n\nexport async function notifyAdminViaLine({ title, preview, url }:{\n  title: string; preview: string; url: string;\n}) {\n  if (process.env.ADMIN\_NOTIFY\_ENABLED === 'false') return; // 一時停止スイッチ\n\n  const groupId = process.env.LINE\_ADMIN\_GROUP\_ID;\n  const userIds = (process.env.LINE\_ADMIN\_USER\_IDS || '')\n    .split(',').map(s=>s.trim()).filter(Boolean);\n\n  const message = {\n    type: 'template' as const,\n    altText: title,\n    template: {\n      type: 'buttons' as const,\n      title,\n      text: preview\.slice(0, 60),\n      actions: \[{ type: 'uri' as const, label: '管理画面を開く', uri: url }]\n    }\n  };\n\n  if (!groupId && userIds.length === 0) {\n    console.warn('No LINE admin target configured (LINE\_ADMIN\_GROUP\_ID / LINE\_ADMIN\_USER\_IDS).');\n    return;\n  }\n  if (groupId) await push({ to: groupId, messages: \[message] });\n  if (userIds.length) await Promise.all(userIds.map(to => push({ to, messages: \[message] })));\n}\n"
    },
    {
    "path": "app/api/chat/send/route.ts",
    "action": "create\_or\_overwrite",
    "language": "ts",
    "content": "import { cookies } from 'next/headers';\nimport { NextResponse } from 'next/server';\nimport { createClient } from '@supabase/supabase-js';\nimport { notifyAdminViaLine } from '@/lib/line/adminNotify';\n\nexport const runtime = 'nodejs';\n\nconst supabase = new createClient(\n  process.env.SUPABASE\_URL!,\n  process.env.SUPABASE\_SERVICE\_ROLE\_KEY!\n);\n\nexport async function POST(req: Request) {\n  const { content, conversationId } = await req.json();\n  const sid = (await cookies()).get('chat\_session')?.value;\n\n  if (!sid || !content?.trim()) {\n    return NextResponse.json({ error: 'bad\_request' }, { status: 400 });\n  }\n\n  // 既存会話の解決\n  let convId = conversationId as string | undefined;\n  if (!convId) {\n    const { data: conv, error } = await supabase\n      .from('conversations')\n      .select('id')\n      .eq('session\_token', sid)\n      .single();\n    if (error) console.error('fetch conversation error', error.message);\n    convId = conv?.id;\n  }\n  if (!convId) return NextResponse.json({ error: 'no\_conversation' }, { status: 400 });\n\n  // 直前メッセージの役割確認（新規 or 管理返信後の追伸だけ通知したい）\n  const { data: last } = await supabase\n    .from('messages')\n    .select('role')\n    .eq('conversation\_id', convId)\n    .order('created\_at', { ascending: false })\n    .limit(1)\n    .maybeSingle();\n\n  const trimmed = String(content).trim();\n\n  // 本文を保存\n  const { error: insErr } = await supabase.from('messages').insert({\n    conversation\_id: convId,\n    role: 'user',\n    source: 'web',\n    content: trimmed\n  });\n  if (insErr) return NextResponse.json({ error: insErr.message }, { status: 500 });\n\n  await supabase\n    .from('conversations')\n    .update({ last\_message\_at: new Date().toISOString() })\n    .eq('id', convId);\n\n  // ===== 通知判定（直前が user ならスキップ）＋ 5分クールダウン =====\n  const candidateByRole = !last || last.role !== 'user';\n  const minutes = Number(process.env.ADMIN\_NOTIFY\_COOLDOWN\_MINUTES || '5');\n  let okByCooldown = false;\n\n  if (candidateByRole) {\n    const { data: allowed, error: rpcErr } = await supabase.rpc('try\_admin\_notify', {\n      p\_conversation\_id: convId,\n      p\_window\_minutes: minutes\n    });\n    okByCooldown = !rpcErr && allowed === true;\n    if (rpcErr) console.error('try\_admin\_notify RPC error', rpcErr.message);\n  }\n\n  if (candidateByRole && okByCooldown) {\n    const preview = trimmed.length > 60 ? trimmed.slice(0, 57) + '…' : trimmed;\n    const url = `${process.env.ADMIN_INBOX_URL}?c=${encodeURIComponent(convId)}`;\n    // 非同期で通知（失敗してもチャットAPIは成功させる）\n    notifyAdminViaLine({ title: 'ユーザーから新着メッセージ', preview, url })\n      .catch(e => console.error('LINE admin notify error', e));\n  }\n  // ===========================================================\n\n  return NextResponse.json({ ok: true, conversationId: convId });\n}\n"
    }
    ],
    "sql\_migrations\_optional\_if\_not\_applied": \[
    "alter table public.conversations add column if not exists admin\_notified\_at timestamptz;",
    "create or replace function public.try\_admin\_notify(p\_conversation\_id uuid, p\_window\_minutes int default 5) returns boolean language plpgsql security definer as $begin update public.conversations set admin_notified_at = now() where id = p_conversation_id and (admin_notified_at is null or admin_notified_at < now() - make_interval(mins => p_window_minutes)); return found; end$;"
    ],
    "api\_contract": \[
    {
    "route": "POST /api/line/webhook",
    "auth": "none (Messaging API 署名検証必須)",
    "body": "LINE webhook payload",
    "behavior": "署名検証に成功した場合のみ 200。source.groupId / userId をログ出力してID収集。"
    },
    {
    "route": "POST /api/chat/send",
    "auth": "cookie: chat\_session（既存）",
    "request": "{ content: string, conversationId?: string }",
    "response": "{ ok: true, conversationId: string } | { error: string }",
    "side\_effects": "messages に INSERT、conversations.last\_message\_at 更新。通知判定OKなら LINE Push を実行（非同期）。"
    }
    ],
    "deployment\_steps": \[
    "A) 上記ファイルを作成/上書き → コミット",
    "B) デプロイ（Preview でも可）",
    "C) LINE Developers で Webhook URL を https\://<DOMAIN>/api/line/webhook に設定→有効化→接続確認",
    "D) LINEアプリで“管理用グループ”を作成→Bot招待→グループで発言→Vercel ログで groupId を確認",
    "E) Vercel 環境変数 LINE\_ADMIN\_GROUP\_ID に groupId を保存（個人宛なら LINE\_ADMIN\_USER\_IDS を設定）→再デプロイ",
    "F) 本流E2Eテスト（下記）"
    ],
    "tests": \[
    {
    "name": "Webhook 署名 OK",
    "steps": \[
    "LINE Developers で接続確認が success になることを確認",
    "グループで発言→ Vercel Logs に 'LINE\_ADMIN\_GROUP\_ID candidate: C...' が出る"
    ],
    "expected": "署名エラーが出ない／200 OK。candidate ログが出力される。"
    },
    {
    "name": "Push 単体テスト（任意）",
    "steps": \[
    "curl -X POST [https://api.line.me/v2/bot/message/push](https://api.line.me/v2/bot/message/push) -H 'Authorization: Bearer \$LINE\_CHANNEL\_ACCESS\_TOKEN' -H 'Content-Type: application/json' -d '{"to":"\<YOUR\_GROUP\_OR\_USER\_ID>","messages":\[{"type":"text","text":"テスト通知"}]}' を実行",
    "グループ/個人にメッセージが届くことを確認"
    ],
    "expected": "通知が届く（401/403 の場合はトークン不整合）"
    },
    {
    "name": "E2E：ユーザー送信→通知",
    "steps": \[
    "ユーザーページからチャット送信",
    "Supabase の messages に行が追加され、conversations.last\_message\_at が更新される",
    "LINE（設定した宛先）に『ユーザーから新着メッセージ』＋『管理画面を開く』ボタンが届く"
    ],
    "expected": "1通通知される（同一会話で5分以内の連投は通知されない）"
    }
    ],
    "troubleshooting": \[
    {
    "symptom": "Webhook のログが出ない / 接続失敗",
    "check": \[
    "LINE\_CHANNEL\_SECRET が正しいか",
    "Webhook URL が https\://<DOMAIN>/api/line/webhook になっているか",
    "Vercel の Functions ログに 401 が出ていないか"
    ],
    "fix": \[
    "チャネルシークレット再確認/ローテート",
    "デプロイの反映待ち（再デプロイ）"
    ]
    },
    {
    "symptom": "Push が届かない",
    "check": \[
    "LINE\_CHANNEL\_ACCESS\_TOKEN の値が最新か（長期トークン）",
    "Bot が対象グループのメンバーか／userId が友だち状態か",
    "to に『名前』ではなく『ID（C... or U...）』を入れているか"
    ],
    "fix": \[
    "トークンを再発行→環境変数更新→再デプロイ",
    "groupId/userId を取り直し"
    ]
    },
    {
    "symptom": "通知が多すぎる",
    "check": \[
    "ADMIN\_NOTIFY\_COOLDOWN\_MINUTES の値",
    "try\_admin\_notify() 関数が適用済みか",
    "直前 role 判定が生きているか（last.role !== 'user'）"
    ],
    "fix": \[
    "クールダウン値を増やす",
    "SQL を再適用",
    "コードの差分を再確認"
    ]
    }
    ],
    "rollback": \[
    "通知のみ緊急停止：環境変数 ADMIN\_NOTIFY\_ENABLED=false → デプロイ",
    "全体停止：NEXT\_PUBLIC\_CHAT\_ENABLED=false（UI非表示）/ CHAT\_API\_DISABLED=true（実装していれば）",
    "DB変更の巻き戻しは不要（機能に影響なし）。必要なら admin\_notified\_at の列と関数を drop"
    ],
    "security\_notes": \[
    "チャネルアクセストークン/シークレットは Vercel の環境変数でのみ保持。コードやログへ出力しない。",
    "このスレッドに貼られたシークレット/トークンは最終的にローテートすること（本番値に差し替え）。",
    "Webhook は署名検証必須。検証NGは 401 を返して処理終了。"
    ],
    "commit\_template": {
    "title": "feat(line-admin-notify): user投稿時の管理LINE通知（5分クールダウン）を実装",
    "body": \[
    "• add: app/api/line/webhook/route.ts（署名検証＋groupId/userId ログ）",
    "• add: lib/line/adminNotify.ts（Messaging API Push ユーティリティ）",
    "• change: app/api/chat/send/route.ts（通知フックと try\_admin\_notify）",
    "• docs: 環境変数と運用手順"
    ]
    }
    }
    